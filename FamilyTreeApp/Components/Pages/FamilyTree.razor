
@inject TreeDataService TreeData;
@inject IJSRuntime JS
@implements IDisposable

@page "/familyTree"
@using Microsoft.AspNetCore.Components.Rendering
@using System.Text.Json
@rendermode InteractiveServer

<PageTitle>FamilyTree</PageTitle>

@if (TreeData.RootNode == null)
{
    <p>No tree data loaded. Please upload a valid JSON file.</p>
}
else
{
    <div class="horizontal-container">
        <button class="toggle-btn" @onclick="ResetFamilyTree">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" 
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                viewBox="0 0 24 24">
                <path d="M2 12a10 10 0 1 1 3.17 7.32" />
                <polyline points="2 12 2 6 8 6" />
            </svg>
        </button>
        <button class="toggle-btn" @onclick="Undo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M3 7v6h6M3 13c1.5-5.5 12-5.5 15-1a9 9 0 0 1 3 5" />
            </svg>
        </button>
        <button class="toggle-btn" @onclick="Redo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M21 7v6h-6M21 13c-1.5-5.5-12-5.5-15-1a9 9 0 0 0-3 5" />
            </svg>
        </button>
    </div>
    <div id="tree-container">
        <ul class= "tree-children">
            @InOrder(TreeData.RootNode)
        </ul>        
    </div>
    @if (_newNodePopUpVisible)
    {
        <div class="new-node-popup-overlay">
            <div class="new-node-popup">
                <h3>Add a New Family Member</h3>

                <label>Full Name:</label><br />
                <input type="text" @bind="_newFullName" /><br />

                <label>Title:</label><br />
                <input type="text" @bind="_newTitle" /><br /><br />
                
                @if (!_canAddNode)
                {
                    <p style="color: red; font-size: 0.9rem;">Both Full Name and Title are required.</p>
                }
                <button class="btn btn-primary" @onclick="AddNode" disabled="@(!_canAddNode)">Add</button>
                <button class="btn btn-secondary" @onclick="@(() => _newNodePopUpVisible = false)">Cancel</button>
            </div>
        </div>
    }
}

@code {
    protected override void OnInitialized()
    {
        TreeData.OnChange += StateHasChanged;
    }

    public void Dispose()
    {
        TreeData.OnChange -= StateHasChanged;
    }

    private RenderFragment InOrder(FamilyTreeNode node) => builder =>
    {       
        if (node == null) return;
        
        int markupElementCount = 0;

        builder.OpenElement(markupElementCount++, "li");
        builder.AddAttribute(markupElementCount++, "class", "tree-node");
        builder.AddAttribute(markupElementCount++, _markupContext, "");

        builder.OpenElement(markupElementCount++, "a");
        builder.AddAttribute(markupElementCount++, "href", "#");
        builder.AddAttribute(markupElementCount++, "class", "tree-label");
        builder.AddAttribute(markupElementCount++, _markupContext, "");

        builder.AddContent(markupElementCount++, node.FullName);
        builder.CloseElement(); // </a>
        
        if (node.Children != null && node.Children.Any())
        {
            int childrenCount = node.Children.Count;
            
            builder.OpenElement(markupElementCount++, "ul");
            builder.AddAttribute(markupElementCount++, "class", "tree-children");
            builder.AddAttribute(markupElementCount++, _markupContext, "");

            for(int i = 0; i < childrenCount; i++) 
            {               
                if (node.Children == null) continue;
                builder.AddContent(markupElementCount++, InOrder(node.Children[i]));
            }

            builder.CloseElement(); // </ul>
        } 
        else 
        {
            builder.OpenElement(markupElementCount++, "ul");
            builder.AddAttribute(markupElementCount++, "class", "tree-children");
            builder.AddAttribute(markupElementCount++, _markupContext, "");

            builder.OpenElement(markupElementCount++, "li");
            builder.AddAttribute(markupElementCount++, "class", "tree-node");
            builder.AddAttribute(markupElementCount++, _markupContext, "");

            builder.OpenElement(markupElementCount++, "button");
            builder.AddAttribute(markupElementCount++, "onclick", EventCallback.Factory.Create(this, () => ShowNewNodePopUp(node)));
            builder.AddAttribute(markupElementCount++, "href", "#");
            builder.AddAttribute(markupElementCount++, "class", "plus-button");
            builder.AddAttribute(markupElementCount++, _markupContext, "");
            builder.AddContent(markupElementCount++, "+");

            builder.CloseElement(); // </a>
            builder.CloseElement(); // </li>
            builder.CloseElement(); // </ul>
        }

        builder.CloseElement(); // </li>
    };
}

@code {
    private bool _canAddNode => 
        !string.IsNullOrWhiteSpace(_newFullName) && 
        !string.IsNullOrWhiteSpace(_newTitle) && 
        _targetParentForAdd != null;

    private bool _newNodePopUpVisible = false;

    private string _markupContext = "b-5gjn933f37"; 
    private string? _newFullName;
    private string? _newTitle;

    private FamilyTreeNode? _targetParentForAdd;
    private Stack<TreeAction> _undoActions = new();
    private Stack<TreeAction> _redoActions = new();
    
    private void ShowNewNodePopUp(FamilyTreeNode parentNode)
    {
        _targetParentForAdd = parentNode;
        _newFullName = "";
        _newTitle = "";
        _newNodePopUpVisible = true;
    }

    private void HideNewNodePopUp()
    {
        _targetParentForAdd = null;
        _newFullName = "";
        _newTitle = "";
        _newNodePopUpVisible = false;
    }

    private void AddNode()
    {
        if (!_canAddNode) return;

        if (_targetParentForAdd.Children == null) _targetParentForAdd.Children = new();

        FamilyTreeNode newNode = new FamilyTreeNode(
            _newFullName,
            _newTitle,
            false
        );

        _targetParentForAdd.Children.Add(newNode);
        _undoActions.Push(new TreeAction
            {
                Type = TreeAction.ActionType.Add,
                AffectedNode = newNode,
                ParentNode = _targetParentForAdd,
                OriginalIndex = _targetParentForAdd.Children.Count - 1
            }
        );

        _redoActions.Clear();
        HideNewNodePopUp();
    }

    private void RemoveNode(FamilyTreeNode parentNode, FamilyTreeNode node)
    {
        int index = parentNode.Children.IndexOf(node);
        parentNode.Children.Remove(node);

        _undoActions.Push(new TreeAction
            {
                Type = TreeAction.ActionType.Remove,
                AffectedNode = node,
                ParentNode = parentNode,
                OriginalIndex = index
            }
        );

        _redoActions.Clear();
    }

    private void ResetFamilyTree()
    {
        FamilyTreeNode? rootNode = JsonSerializer.Deserialize<FamilyTreeNode>(
            TreeData.UploadedJson,
            new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                WriteIndented = true
            }
        );

        if (rootNode != null) 
        {
            TreeData.SetRootNode(rootNode);
            Console.WriteLine("Read the json file.");
        }
    }

    private void Undo()
    {
        if (!_undoActions.Any()) return;

        TreeAction treeAction = _undoActions.Pop();
        _redoActions.Push(treeAction);

        switch (treeAction.Type) 
        {
            case TreeAction.ActionType.Add:
                treeAction.ParentNode.Children.Remove(treeAction.AffectedNode);
                break;
            case TreeAction.ActionType.Remove:
                treeAction.ParentNode.Children.Insert(treeAction.OriginalIndex, treeAction.AffectedNode);
                break;
        }
    }

    private void Redo()
    {
        if (!_redoActions.Any()) return;

        TreeAction treeAction = _redoActions.Pop();
        _undoActions.Push(treeAction);

        switch (treeAction.Type) 
        {
            case TreeAction.ActionType.Add:
                treeAction.ParentNode.Children.Insert(treeAction.OriginalIndex, treeAction.AffectedNode);
                break;
            case TreeAction.ActionType.Remove:
                treeAction.ParentNode.Children.Remove(treeAction.AffectedNode);
                break;
        }
    }
}
