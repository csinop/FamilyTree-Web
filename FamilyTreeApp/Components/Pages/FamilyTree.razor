
@inject TreeDataService TreeData;
@inject IJSRuntime JS
@implements IDisposable

@page "/familyTree"
@using Microsoft.AspNetCore.Components.Rendering
@using System.Text.Json
@rendermode InteractiveServer

<PageTitle>FamilyTree</PageTitle>

@if (TreeData.RootNode == null)
{
    <p>No tree data loaded. Please upload a valid JSON file.</p>
}
else
{
    <div class="horizontal-container">
        <button class="toggle-btn" @onclick="ResetFamilyTree">Reset Tree</button>
        <button class="toggle-btn" @onclick="Undo">Undo</button>
        <button class="toggle-btn" @onclick="Redo">Redo</button>
    </div>
    <div id="tree-container">
        <ul class= "tree-children">
            @InOrder(TreeData.RootNode)
        </ul>        
    </div>
}

@code {
    protected override void OnInitialized()
    {
        TreeData.OnChange += StateHasChanged;
    }

    public void Dispose()
    {
        TreeData.OnChange -= StateHasChanged;
    }

    private RenderFragment InOrder(FamilyTreeNode node) => builder =>
    {       
        if (node == null) return;
        
        int markupElementCount = 0;

        builder.OpenElement(markupElementCount++, "li");
        builder.AddAttribute(markupElementCount++, "class", "tree-node");
        builder.AddAttribute(markupElementCount++, _markupContext, "");

        builder.OpenElement(markupElementCount++, "a");
        builder.AddAttribute(markupElementCount++, "href", "#");
        builder.AddAttribute(markupElementCount++, "class", "tree-label");
        builder.AddAttribute(markupElementCount++, _markupContext, "");

        builder.AddContent(markupElementCount++, node.FullName);
        builder.CloseElement(); // </a>
        
        if (node.Children != null && node.Children.Any())
        {
            int childrenCount = node.Children.Count;
            
            builder.OpenElement(markupElementCount++, "ul");
            builder.AddAttribute(markupElementCount++, "class", "tree-children");
            builder.AddAttribute(markupElementCount++, _markupContext, "");

            for(int i = 0; i < childrenCount; i++) 
            {               
                if (node.Children == null) continue;
                builder.AddContent(markupElementCount++, InOrder(node.Children[i]));
            }

            builder.CloseElement(); // </ul>
        } 
        else 
        {
            builder.OpenElement(markupElementCount++, "ul");
            builder.AddAttribute(markupElementCount++, "class", "tree-children");
            builder.AddAttribute(markupElementCount++, _markupContext, "");

            builder.OpenElement(markupElementCount++, "li");
            builder.AddAttribute(markupElementCount++, "class", "tree-node");
            builder.AddAttribute(markupElementCount++, _markupContext, "");

            builder.OpenElement(markupElementCount++, "button");
            builder.AddAttribute(markupElementCount++, "onclick", EventCallback.Factory.Create(this, () => AddNode("a", node)));
            builder.AddAttribute(markupElementCount++, "href", "#");
            builder.AddAttribute(markupElementCount++, "class", "plus-button");
            builder.AddAttribute(markupElementCount++, _markupContext, "");
            builder.AddContent(markupElementCount++, "+");

            builder.CloseElement(); // </a>
            builder.CloseElement(); // </li>
            builder.CloseElement(); // </ul>
        }

        builder.CloseElement(); // </li>
    };
}

@code {  
    private string _markupContext = "b-5gjn933f37";
    private Stack<TreeAction> _undoActions = new();
    private Stack<TreeAction> _redoActions = new();

    private void AddNode(string content, FamilyTreeNode parentNode)
    {
        if (parentNode.Children == null) parentNode.Children = new();

        FamilyTreeNode newNode = new FamilyTreeNode(
            content,
            "test",
            false
        );

        parentNode.Children.Add(newNode);
        _undoActions.Push(new TreeAction
            {
                Type = TreeAction.ActionType.Add,
                AffectedNode = newNode,
                ParentNode = parentNode,
                OriginalIndex = parentNode.Children.Count - 1
            }
        );

        _redoActions.Clear();
    }

    private void RemoveNode(FamilyTreeNode parentNode, FamilyTreeNode node)
    {
        int index = parentNode.Children.IndexOf(node);
        parentNode.Children.Remove(node);

        _undoActions.Push(new TreeAction
            {
                Type = TreeAction.ActionType.Remove,
                AffectedNode = node,
                ParentNode = parentNode,
                OriginalIndex = index
            }
        );

        _redoActions.Clear();
    }

    private void ResetFamilyTree()
    {
        FamilyTreeNode? rootNode = JsonSerializer.Deserialize<FamilyTreeNode>(
            TreeData.UploadedJson,
            new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                WriteIndented = true
            }
        );

        if (rootNode != null) 
        {
            TreeData.SetRootNode(rootNode);
            Console.WriteLine("Read the json file.");
        }
    }

    private void Undo()
    {
        if (!_undoActions.Any()) return;

        TreeAction treeAction = _undoActions.Pop();
        _redoActions.Push(treeAction);

        switch (treeAction.Type) 
        {
            case TreeAction.ActionType.Add:
                treeAction.ParentNode.Children.Remove(treeAction.AffectedNode);
                break;
            case TreeAction.ActionType.Remove:
                treeAction.ParentNode.Children.Insert(treeAction.OriginalIndex, treeAction.AffectedNode);
                break;
        }
    }

    private void Redo()
    {
        if (!_redoActions.Any()) return;

        TreeAction treeAction = _redoActions.Pop();
        _undoActions.Push(treeAction);

        switch (treeAction.Type) 
        {
            case TreeAction.ActionType.Add:
                treeAction.ParentNode.Children.Insert(treeAction.OriginalIndex, treeAction.AffectedNode);
                break;
            case TreeAction.ActionType.Remove:
                treeAction.ParentNode.Children.Remove(treeAction.AffectedNode);
                break;
        }
    }
}
