@inject TreeDataService TreeData;
@inject IJSRuntime JS
@implements IDisposable

@page "/familyTree"
@using Microsoft.AspNetCore.Components.Rendering
@using System.Text.Json
@rendermode InteractiveServer

<PageTitle>FamilyTree</PageTitle>

@if (TreeData.RootNode == null)
{
    <p>No tree data loaded. Please upload a valid JSON file.</p>
}
else
{
    <div class="horizontal-container">
        <button class="toggle-btn" @onclick="ResetFamilyTree">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" 
                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
                viewBox="0 0 24 24">
                <path d="M2 12a10 10 0 1 1 3.17 7.32" />
                <polyline points="2 12 2 6 8 6" />
            </svg>
        </button>
        <button class="toggle-btn" @onclick="Undo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M3 7v6h6M3 13c1.5-5.5 12-5.5 15-1a9 9 0 0 1 3 5" />
            </svg>
        </button>
        <button class="toggle-btn" @onclick="Redo">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M21 7v6h-6M21 13c-1.5-5.5-12-5.5-15-1a9 9 0 0 0-3 5" />
            </svg>
        </button>
    </div>
    <div id="tree-container">
        <ul class= "tree-children">
            @InOrder(TreeData.RootNode)
        </ul>        
    </div>
    @if (_newNodePopUpVisible)
    {
        <div class="new-node-popup-overlay">
            <div class="new-node-popup">
                <h3>Add a New Family Member</h3>
                <select @bind="_selectedRelationship">
                    <option value="Child">Child</option>
                    <option value="Sibling">Sibling</option>
                    <option value="Spouse">Spouse</option>
                </select>
                <label>Full Name:</label><br />
                <input type="text" @bind="_newFullName" /><br />

                <label>Title:</label><br />
                <input type="text" @bind="_newTitle" /><br /><br />

                @if (!_canAddNode)
                {
                    <p style="color: red; font-size: 0.9rem;">Both Full Name and Title are required.</p>
                }
                <button class="btn btn-primary" @onclick="AddNode" disabled="@(!_canAddNode)">Add</button>
                <button class="btn btn-secondary" @onclick="@(() => _newNodePopUpVisible = false)">Cancel</button>
            </div>
        </div>
    }
}

@code {
    private RenderFragment InOrder(FamilyTreeNode node) => builder =>
    {       
        if (node == null) return;
        
        int sequence = 0;

        builder.OpenElement(sequence++, "li");
        builder.AddAttribute(sequence++, "class", "tree-node");
        builder.AddAttribute(sequence++, _markupContext, "");

        builder.OpenElement(sequence++, "div");
        builder.AddAttribute(sequence++, "class", "person-pair");
        builder.AddAttribute(sequence++, _markupContext, "");
        
        if (node.Spouse != null)
        {
            builder.OpenElement(sequence++, "a");
            builder.AddAttribute(sequence++, "class", "tree-label spouse");
            builder.AddAttribute(sequence++, _markupContext, "");
            builder.AddContent(sequence++, node.Spouse.FullName);
            builder.CloseElement();

            builder.OpenElement(sequence++, "span");
            builder.AddAttribute(sequence++, "class", "spouse-connector");
            builder.AddAttribute(sequence++, _markupContext, "");
            builder.CloseElement();
        }

        builder.OpenElement(sequence++, "a");
        builder.AddAttribute(sequence++, "href", "#");
        builder.AddAttribute(sequence++, "class", "tree-label");
        builder.AddAttribute(sequence++, _markupContext, "");

        builder.AddContent(sequence++, node.FullName);
        builder.CloseElement(); // </a>
        builder.CloseElement(); // </div>
        
        if (node.Children != null && node.Children.Any())
        {
            int childrenCount = node.Children.Count;
            
            builder.OpenElement(sequence++, "ul");
            builder.AddAttribute(sequence++, "class", "tree-children");
            builder.AddAttribute(sequence++, _markupContext, "");

            for(int i = 0; i < childrenCount; i++) 
            {         
                if (node.Children == null) continue;
                builder.AddContent(sequence++, InOrder(node.Children[i]));
            }

            builder.CloseElement(); // </ul>
        }
        else 
        {
            builder.OpenElement(sequence++, "ul");
            builder.AddAttribute(sequence++, "class", "tree-children");
            builder.AddAttribute(sequence++, _markupContext, "");

            RenderAddButton(builder, ref sequence, node);

            builder.CloseElement(); // </ul>
        }

        builder.CloseElement(); // </li>
    };

    private void RenderAddButton(RenderTreeBuilder builder, ref int sequence, FamilyTreeNode selectedNode)
    {
        builder.OpenElement(sequence++, "li");
        builder.AddAttribute(sequence++, "class", "tree-node");
        builder.AddAttribute(sequence++, _markupContext, "");

        builder.OpenElement(sequence++, "button");
        builder.AddAttribute(sequence++, "onclick", EventCallback.Factory.Create(this, () => ShowNewNodePopUp(selectedNode)));
        builder.AddAttribute(sequence++, "href", "#");
        builder.AddAttribute(sequence++, "class", "plus-button");
        builder.AddAttribute(sequence++, _markupContext, "");
        builder.AddContent(sequence++, "+");

        builder.CloseElement(); // </button>
        builder.CloseElement(); // </li>
    }
}

@code {
    private FamilyTreeNode.RelationshipType _selectedRelationship = FamilyTreeNode.RelationshipType.Child;
    private bool _canAddNode => 
        !string.IsNullOrWhiteSpace(_newFullName) && 
        !string.IsNullOrWhiteSpace(_newTitle) && 
        _selectedNodeForInsert != null;

    private bool _newNodePopUpVisible = false;

    private string _markupContext = "b-5gjn933f37"; 
    private string? _newFullName;
    private string? _newTitle;

    private FamilyTreeNode? _selectedNodeForInsert;
    private Stack<TreeAction> _undoActions = new();
    private Stack<TreeAction> _redoActions = new();
    
    private void ShowNewNodePopUp(FamilyTreeNode parentNode)
    {
        _selectedNodeForInsert = parentNode;
        _newFullName = "";
        _newTitle = "";
        _newNodePopUpVisible = true;
    }

    private void HideNewNodePopUp()
    {
        _selectedNodeForInsert = null;
        _newFullName = "";
        _newTitle = "";
        _newNodePopUpVisible = false;
    }

    private void AddNode()
    {
        if (!_canAddNode || _selectedNodeForInsert == null) return;

        _selectedNodeForInsert.Children ??= new List<FamilyTreeNode>();

        FamilyTreeNode newNode = new FamilyTreeNode
        {
            FullName = _newFullName,
            Title = _newTitle
        };

        switch(_selectedRelationship)
        {
            case FamilyTreeNode.RelationshipType.Child:
                _selectedNodeForInsert.Children ??= new List<FamilyTreeNode>();
                _selectedNodeForInsert.Children.Add(newNode);
                newNode.Parent = _selectedNodeForInsert;

                _undoActions.Push(new TreeAction
                    {
                        Type = TreeAction.ActionType.Add,
                        AffectedNode = newNode,
                        ParentNode = _selectedNodeForInsert,
                        OriginalIndex = _selectedNodeForInsert.Children.Count - 1
                    }
                );
                break;

            case FamilyTreeNode.RelationshipType.Spouse:
                _selectedNodeForInsert.Spouse = newNode;
                newNode.Parent = _selectedNodeForInsert.Parent;

                _undoActions.Push(new TreeAction
                    {
                        Type = TreeAction.ActionType.Add,
                        AffectedNode = newNode,
                        ParentNode = _selectedNodeForInsert,
                        OriginalIndex = -1
                    }
                );
                break;

            case FamilyTreeNode.RelationshipType.Sibling:
                FamilyTreeNode parent = _selectedNodeForInsert.Parent;

                if (parent == null) break;

                parent.Children ??= new List<FamilyTreeNode>();
                parent.Children.Add(newNode);
                newNode.Parent = parent;

                _undoActions.Push(new TreeAction
                    {
                        Type = TreeAction.ActionType.Add,
                        AffectedNode = newNode,
                        ParentNode = parent,
                        OriginalIndex = parent.Children.Count - 1
                    }
                );
                break;

        }

        _redoActions.Clear();
        HideNewNodePopUp();
    }

    private void RemoveNode(FamilyTreeNode parentNode, FamilyTreeNode node)
    {
        if (parentNode == null) return;
        if (parentNode.Children == null) return;

        int index = parentNode.Children.IndexOf(node);
        parentNode.Children.Remove(node);

        _undoActions.Push(new TreeAction
            {
                Type = TreeAction.ActionType.Remove,
                AffectedNode = node,
                ParentNode = parentNode,
                OriginalIndex = index
            }
        );

        _redoActions.Clear();
    }

    private void ResetFamilyTree()
    {
        FamilyTreeNode? rootNode = JsonSerializer.Deserialize<FamilyTreeNode>(
            TreeData.UploadedJson,
            new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                WriteIndented = true
            }
        );

        if (rootNode != null) 
        {
            TreeData.SetRootNode(rootNode);
            Console.WriteLine("Read the json file.");
        }
    }

    private void Undo()
    {
        if (!_undoActions.Any()) return;

        TreeAction treeAction = _undoActions.Pop();

        if (treeAction == null) return;
        if (treeAction.ParentNode == null) return;
        if (treeAction.ParentNode.Children == null) return;

        _redoActions.Push(treeAction);

        switch (treeAction.Type) 
        {
            case TreeAction.ActionType.Add:
                treeAction.ParentNode.Children.Remove(treeAction.AffectedNode);
                break;
            case TreeAction.ActionType.Remove:
                treeAction.ParentNode.Children.Insert(treeAction.OriginalIndex, treeAction.AffectedNode);
                break;
        }
    }

    private void Redo()
    {
        if (!_redoActions.Any()) return;

        TreeAction treeAction = _redoActions.Pop();

        if (treeAction == null) return;
        if (treeAction.ParentNode == null) return;
        if (treeAction.ParentNode.Children == null) return;

        _undoActions.Push(treeAction);

        switch (treeAction.Type) 
        {
            case TreeAction.ActionType.Add:
                treeAction.ParentNode.Children.Insert(treeAction.OriginalIndex, treeAction.AffectedNode);
                break;
            case TreeAction.ActionType.Remove:
                treeAction.ParentNode.Children.Remove(treeAction.AffectedNode);
                break;
        }
    }

    protected override void OnInitialized()
    {
        TreeData.OnChange += StateHasChanged;
    }

    public void Dispose()
    {
        TreeData.OnChange -= StateHasChanged;
    }
}
